HW7: Locking
============
Shantanu Jain
6.828 Fall 2016
10/15/2016

#Don't Do This

You will deadlock. The reason is that `spinlock.c:acquire()` is a blocking call. This means that it will constantly spin until it manages to acquire the lock. In the last line of the example code, since the lock has already been acquired (and will never be released, because all the code is happening in the same thread), the thread will simply block and run forever.

#Race in ide.c

With the code we added, we are allowing interrupts to happen while holding a lock. The kernel panics in the IDE driver because another interrupt happens while the lock is being held, which means the ide queue gets corrupted. 

#Race in file.c

This does not panic becasue the file table does not get corrupted since there are no interrupts that affect the file table. The only functions manipulating the file table filealloc(), filedup(), and fileclose(), none of which are invoked from an interrupt. Since there is only 1 thread of execution when booting the kernel, this is OK. However I think the file table data structure may become corrupt in userland, since once userland is running, we have more than 1 thread (and more than 1 CPU) that may be manipulating multiple files. 

#xv6 lock implementation

The spinlock implementation clears lk->pcs[0] and lk->cpu before releasing the lock so that there is no race condition on these data fields! Otherwise the lock may be released, another thread may acquire the lock, and set these debugging variables, and then the releasing thread would clear these variables. Basically the lock is protecting its own data structures with itself.
